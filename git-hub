#!/usr/bin/env python3
import subprocess
import github
import yaml
import click
import sys
import textwrap
import json
import toml
import app
import os
from datetime import datetime
from urllib.request import urlopen, Request
from os.path import join as pjoin


def login():
    """Retrieves the user's remote.

    Returns
    -------
    username : string
        username of the remote
    repo : string
        repository of the remote
    remote : string
        returns remotes

    """
    process = subprocess.Popen(["git", "remote", "-v"], stdout=subprocess.PIPE)
    remotes = str(process.stdout.read())
    url = remotes.split(" ", 1)[0]  # gets the fetch url
    arguments = url.split(".com")[1]  # gets just the username/repo.git
    arguments = arguments[1:]
    arguments = arguments.split(".git")[0]  # takes out ".git"
    username, repo = arguments.split("/")
    return (username, repo, remotes)


def get_token():
    """Retrieve token from configuration file.

    Returns
    -------
    token : string
        a number corresponding to user's authentication
    """
    token = ""
    if os.path.isfile(os.path.expanduser("~/.config/git-hub.yaml")):
        with open(os.path.expanduser("~/.config/git-hub.yaml")) as stream:
            yaml_file = str(yaml.load(stream))
            token = yaml_file.split("=")[1].strip()
    else:
        token = os.environ['GITHUB_TOKEN']

    if (token is not ""):
        return token
    else:
        print(textwrap.dedent("""\
            No authentication token specified in: ~/.config/git-hub.yaml

            Please see

              https://help.github.com/articles/creating-a-personal-access-token-for-the-command-line/

            for instruction on obtaining a token.  Then update the configuration
            file as follows:

              token = abc123
        """))
        sys.exit(1)


def pr(num):
    """Pulls down and checkout the branch of the pr.

    This will run the following commands in the terminal:
    "git remote add user git@github.com:user/repo",
    "git fetch user",
    "git checkout -b pr/num user/branch"

    Parameters
    ----------
    num : integer
        The number of the pull request.
    """
    username, repo, remotes = login()
    token = get_token()

    # gets pr and runs command.
    try:
        g = github.Github(token)
        pr = g.get_user(username).get_repo(repo).get_pull(num)
        label = pr.head.label
        other_user, branch = label.split(":")
        process = subprocess.Popen(["git", "remote", "-v"], stdout=subprocess.PIPE)
        remotes = str(process.stdout.read())
        remote_name = "\\n" + other_user + "\\t"
        if remote_name not in remotes:
            p = subprocess.Popen(["git", "remote", "add", other_user, f'git@github.com:{other_user}/{repo}'])
            p.communicate()
        p = subprocess.Popen(["git", "fetch", other_user],
                             stdout=subprocess.PIPE)
        p.stdout.read()
        subprocess.Popen(["git", "checkout", "-b",
                         f'pr/{num}', f'{other_user}/{branch}'])
        file_path = path_to_git()
        file_path = os.path.join(file_path, '.git_hub_cache')
        with open(file_path, "a+") as f:
            if os.stat(file_path).st_size == 0:  # check if empty
                f.write("#This file contains metadata about pull requests. \n")
        with open(file_path, "r") as f:
            pr_dict = toml.load(f)
        if f'pr/{num}' not in pr_dict:
            with open(file_path, "a") as f:
                f.write((f"\n ['pr/{num}'] \n'branch' = '{branch}' \n"
                        f"'user' = '{other_user}' \n"))

    except github.BadCredentialsException as e:
        print(e)
        print("The authentification token is not valid.")
        sys.exit(1)

    except github.UnknownObjectException as e:
        print(e)
        print(f'There is no pr with number {num}.')
        sys.exit(1)


def push():
    """Pushes changes back to a branch.

    This will run the following command:
    "git push user pr/num:branch"

    """
    p = subprocess.Popen("git branch", stdout=subprocess.PIPE)
    pr = str(p.stdout.read())
    pr = pr.split("*", 1)[1].split()[0]
    pr = pr.replace("\\n", "").replace(" ", "").replace("'", "")
    try:
        file_path = path_to_git()
        file_path = os.path.join(file_path, '.git_hub_cache')
        with open(file_path, "r") as f:
            pr_dict = toml.load(f)
        user = pr_dict[pr]['user']
        branch = pr_dict[pr]["branch"]
        p = subprocess.Popen(["git", "push", user,
                             f'{pr}:{branch}'], stdout=subprocess.PIPE)
        p.stdout.read()
        print(["git", "push", user, f'{pr}:{branch}'])
    except FileNotFoundError as e:
        print(e)
        print("This command must be used after git hub pr.")
        sys.exit(1)


def path_to_git():
    """Finds path to .git folder
    """
    path_repo = os.path.abspath('.')
    # if not in directory with .git, keep going back to find file
    while os.path.abspath(path_repo) != '/' and not os.path.isdir(pjoin(path_repo, '.git')):
        path_repo = pjoin(path_repo, '..')
    path_git = pjoin(path_repo, ".git")
    return path_git


def path_to_toml():
    """Finds path to pull-requests.toml
    """
    path_git = path_to_git()
    path_github = pjoin(path_git, 'git-hub')
    path_prs = pjoin(path_github, 'pull-requests.toml')
    return path_prs


def find_in_dictionary(pr_data, open_or_closed_dictionary):
    """Fetches all the information on a certain PR

    Parameters
    ----------
    Pr_data : integer
        number of PR to fetch information from
    Open_or_closed_dictionary : dictionary
        dictionary of open or closed PRs to find number in
    """
    if(open_or_closed_dictionary is not None):
        for dictionary in open_or_closed_dictionary:
            for sub_keys in list(dictionary.keys()):
                if(sub_keys == str(pr_data)):
                    return sub_keys, dictionary[sub_keys]
    return None, None


def get_info(pr_data):
    """Fetches all the information on a certain PR

    Parameters
    ----------
    Pr_data : integer
        number of PR to fetch information from
    """

    try:
        path_prs = path_to_toml()
        f = open(path_prs, "r")
        pr_dict = toml.load(f)      # fetches toml file and creates a dictionary
        open_dict = pr_dict['open pull requests']
        closed_dict = pr_dict['closed pull requests']
    except (OSError, IOError) as e:
        # if pull-requests.toml hasnt been created yet calls sync and then reties to fetch
        sync()
        get_info(pr_data)

    open_PR = "O"
    key, pr_dictionary = find_in_dictionary(pr_data, open_dict)
    if(pr_dictionary is None):
        open_PR = "C"
        key, pr_dictionary = find_in_dictionary(pr_data, closed_dict)
    if(pr_dictionary is None):
        click.echo("Could not find PR #{}. Run 'git hub sync' and try again.".format(pr_data))
    else:
        reviewers = "None"
        if(pr_dictionary['reviewers'] is not ""):
            reviewers = pr_dictionary['reviewers']
        assignee = "None"
        if(pr_dictionary['assignee'] is not ""):
            assignee = pr_dictionary['assignee']
        milestone = "None"
        if(pr_dictionary['milestone'] is not ""):
            milestone = pr_dictionary['milestone']
        labels = "None"
        if(pr_dictionary['labels'] is not ""):
            labels = pr_dictionary['labels']
        branch = "None"
        if(pr_dictionary['branch'] is not ""):
            branch = pr_dictionary['branch']
        commits = "None"
        if(pr_dictionary['commits'] is not ""):
            commits = pr_dictionary['commits']
        most_recent_comment = "None"
        if(pr_dictionary['most_recent_comment'] is not ""):
            most_recent_comment = parse_time(pr_dictionary['most_recent_comment'])
        comment_count = "None"
        if(pr_dictionary['comment_count'] is not ""):
            comment_count = pr_dictionary['comment_count']
        created_at = "None"
        if(pr_dictionary['created_at'] is not ""):
            created_at = parse_time(pr_dictionary['created_at'])
        updated_at = "None"
        if(pr_dictionary['updated_at'] is not ""):
            updated_at = parse_time(pr_dictionary['updated_at'])
        GREEN = '\x1b[0;32;40m'
        CLOSE = '\x1b[0m'
        click.echo('{0} {1} {2} {3} {4}/{5} {6}'.format(key, GREEN, open_PR, CLOSE, pr_dictionary['user'], pr_dictionary['branch'], pr_dictionary['comment']))
        click.echo('-Created at: {0}  -Updated at: {1}'.format(created_at, updated_at))
        click.echo('-Commits: {0}  -Comment count: {1}  -Most recent comment: {2}'.format(commits, comment_count, most_recent_comment))
        click.echo('-Labels: {0}  -Reviewers: {1}  -Branch: {2}  -Assignees: {3}  -Milestones: {4}'.format(labels, reviewers, branch, assignee, milestone))


def parse_time(time):
    """
    Converts time into python datetime object

    Parameters
    ----------
    Time : String
        Time that git-hub gives
    """
    date = time.split('T')[0]
    time = time.split('T')[1][:-1]
    year, date = date.split('-', 1)
    month, date = date.split('-', 1)
    day = date
    hour, time = time.split(':', 1)
    minute, time = time.split(':', 1)
    second = time
    d = datetime(int(year), int(month), int(day), int(hour), int(minute), int(second))
    return d


def print_in_order(dict, increasing=False):
    """
    Prints items in q sorted by order given by sort

    Parameters
    ----------
    Q : PriorityQueue
        items to be sorted, currently in increasing order
    Inreasing : boolean
        tells if the user wants dates in order of most recent first
    """
    if(increasing):
        sorted_list = sorted(dict)
        for x in sorted_list:
            click.echo("{0} : {1}".format(dict[x], x[:10]))
    else:
        sorted_list = sorted(dict, reverse=True)
        for x in sorted_list:
            click.echo("{0} : {1}".format(dict[x], x[:10]))


def find_match(open_or_closed, list_of_dictionaries, keyword, user, comment, number, branch, label):
    """Helper function that finds all matches in the given dictionary that fits the specified parameters

    Parameters
    ----------
    Open_or_closed : boolean
        Whether looking in closed PR or open PR
    List_of_dictionaries : dictionary
        pull-requests.toml information mapping PR number to info
    Keyword : string
        Searches if any part of user, branch, comment, or number match
    User : string
        Search by PR username
    Comment : string
        Search by PR comment
    Number : string
        Search by PR number
    Branch : string
        Search by PR branch

    Returns
    ----------
    Appeared_before : boolean
        Whether the search match is the first match
    All_prs : list
        All the prs that match the criteria
    """
    appeared_before = False
    all_prs = {}
    GREEN = '\x1b[0;32;40m'
    RED = '\x1b[0;31;40m'
    CLOSE = '\x1b[0m'
    for dictionary in list_of_dictionaries:        # iterates through and checks if open pull requsts have keyword
        for sub_keys in list(dictionary.keys()):
            sub_dictionary = dictionary[sub_keys]
            if keyword:         # checks keyword
                concate = " ".join(sub_dictionary.values())
                if keyword.upper() in concate.upper():
                    appeared_before = True
                    if(open_or_closed):
                        all_prs[sub_dictionary['modified']] = '{0} {1} {2} {3} {4}/{5} {6}'.format(sub_keys, GREEN, "O", CLOSE, sub_dictionary['user'], sub_dictionary['branch'], sub_dictionary['comment'])
                    else:
                        all_prs[sub_dictionary['modified']] = '{0} {1} {2} {3} {4}/{5} {6}'.format(sub_keys, RED, "C", CLOSE, sub_dictionary['user'], sub_dictionary['branch'], sub_dictionary['comment'])
            else:               # checks for all other parameters
                temp_user = sub_dictionary['user']
                temp_branch = sub_dictionary["branch"]
                temp_comment = sub_dictionary["comment"]
                temp_label = sub_dictionary["labels"]
                if label.upper() in temp_label.upper() and comment.upper() in temp_comment.upper() and user.upper() in temp_user.upper() and branch.upper() in temp_branch.upper():
                    appeared_before = True
                    if(open_or_closed):
                        all_prs[sub_dictionary['modified']] = '{0} {1} {2} {3} {4}/{5} {6}'.format(sub_keys, GREEN, "O", CLOSE, sub_dictionary['user'], sub_dictionary['branch'], sub_dictionary['comment'])
                    else:
                        all_prs[sub_dictionary['modified']] = '{0} {1} {2} {3} {4}/{5} {6}'.format(sub_keys, RED, "C", CLOSE, sub_dictionary['user'], sub_dictionary['branch'], sub_dictionary['comment'])
    return appeared_before, all_prs


def search(keyword, user, comment, number, branch, opened_or_closed, label, sort):
    """Searches open and closed pull request comments for specified keyword.

    Opens pull-requests.toml file in .git folder to fetch pull requests.

    Parameters
    ----------
    Keyword : string
        Searches if any part of user, branch, comment, or number match
    User : string
        Search by PR username
    Comment : string
        Search by PR comment
    Number : string
        Search by PR number
    Branch : string
        Search by PR branch
    """
    try:
        open_prs = False
        closed_prs = False
        path_prs = path_to_toml()
        f = open(path_prs, "r")
        pr_dict = toml.load(f)      # fetches toml file and creates a dictionary
    except (OSError, IOError) as e:
        # if pull-requests.toml hasnt been created yet calls sync and then reties to fetch
        sync()
        search(keyword, user, comment, number, branch, opened_or_closed, label, sort)

    open_dict = pr_dict['open pull requests']
    closed_dict = pr_dict['closed pull requests']
    if(not opened_or_closed or opened_or_closed.lower() == 'open'):
        open_prs, q = find_match(True, open_dict, keyword, user, comment, number, branch, label)
        print_in_order(q, sort.startswith('i'))
    if(not opened_or_closed or opened_or_closed.lower() == 'closed'):
        closed_prs, q = find_match(False, closed_dict, keyword, user, comment, number, branch, label)
        print_in_order(q, sort.startswith('i'))
    if not open_prs and not closed_prs:     # outputs if keyword was not contained in pull requets comments
        click.echo("Could not find in pull requests. Update your pull requests with 'git hub sync' and try again.")


def find_pr_info(username, repo, pr, token, open_or_closed):
    """Helper function that finds all the information we want to record from the
    pull requests from the API and converts it to toml format syntax

    Parameters
    ----------
    Username : string
        username created of PR
    Repo : string
        repo user created PR from
    Pr : object
        PR dictionary
    Token : string
        authentication token for user
    Open_or_closed : string
        if the PR is open or closed
    """
    to_write = ""
    url = 'https://api.github.com/repos/{0}/{1}/pulls/{2}'.format(username, repo, pr.number)
    request = Request(url)
    request.add_header('Authorization', 'token %s' % token)
    response = urlopen(request)
    response = json.loads(response.read().decode('utf-8'))
    to_write = to_write + "['{0} pull requests'.{1}]\n".format(open_or_closed, pr.number)
    to_write = to_write + 'title = "{0}" \n'.format(response.get('title'))
    to_write = to_write + 'body = "{0}" \n'.format(response.get('body'))
    to_write = to_write + 'user = "{0}" \n'.format(pr.user.login)
    to_write = to_write + 'branch = "{0}" \n'.format(response.get('head').get('ref'))
    to_write = to_write + 'mergeable = "{0}" \n'.format(pr.mergeable)
    to_write = to_write + 'comment = "{0}" \n'.format(pr.title)
    to_write = to_write + 'commits = "{0}" \n'.format(response.get('commits'))
    to_write = to_write + 'modified = "{0}" \n'.format(pr.updated_at)
    to_write = to_write + 'created_at = "{0}" \n'.format(response.get('created_at'))
    to_write = to_write + 'updated_at = "{0}" \n'.format(response.get('updated_at'))
    to_write = to_write + 'closed_at = "{0}" \n'.format(response.get('closed_at'))
    to_write = to_write + 'merged_at = "{0}" \n'.format(response.get('merged_at'))
    reviewers = ""
    for reviewer in list(response.get('requested_reviewers')):
        reviewers = reviewers + reviewer.get('login')+", "
    to_write = to_write + 'reviewers = "{0}" \n'.format(reviewers[:-2])
    assignees = ""
    for assignee in list(response.get('assignees')):
        assignees = assignees + assignee.get('login')+", "
    to_write = to_write + 'assignee = "{0}" \n'.format(assignees[:-2])
    if(pr.milestone):
        to_write = to_write + 'milestone = "{0}" \n'.format(pr.milestone.title)
    else:
        to_write = to_write + 'milestone = "" \n'

    issue_url = response.get('issue_url')       # fetches labels attached to pull requests
    labels = ""
    issue_request = Request(issue_url)
    issue_response = urlopen(issue_request)
    issue_response = json.loads(issue_response.read().decode('utf-8'))
    labels_dict = issue_response.get('labels')
    for label in list(labels_dict):
        labels = labels + label.get('name')+", "
    to_write = to_write + 'labels = "{0}" \n'.format(labels[:-2])

    comment_url = response.get('comments_url')       # fetches latest activity (comment) date
    comment_count = 0
    most_recent = ""
    self_comment = False
    comment_dates = []
    comment_content = []
    comment_request = Request(comment_url)
    comment_response = urlopen(comment_request)
    comment_dict = json.loads(comment_response.read().decode('utf-8'))
    for c in list(comment_dict):
        comment_count = comment_count + 1
        comment_content.append(c.get("body"))
        date = c.get('updated_at')
        comment_dates.append(date)
        if most_recent == "" or date > most_recent:
            most_recent = date
        commenter = c.get('user').get('login')
        if commenter == username:
            self_comment = True
    to_write = to_write + 'comment_count = "{0}" \n'.format(comment_count)
    to_write = to_write + 'most_recent_comment = "{0}" \n'.format(most_recent)
    to_write = to_write + 'self_comment = "{0}" \n'.format(self_comment)
    to_write = to_write + 'comment_dates = {0} \n'.format(comment_dates)

    to_write = to_write + 'comment_content = {0} \n'.format(comment_content)

    return to_write


def find_issue_info(username, repo, issue, token):
    """Helper function that finds all the information we want to record from the issues
    from the API and converts it to toml format syntax

    Parameters
    ----------
    Username : string
        username created of PR
    Repo : string
        repo user created PR from
    Pr : object
        PR dictionary
    Token : string
        authentication token for user
    """
    to_write = ""
    url = 'https://api.github.com/repos/{0}/{1}/issues/{2}'.format(username, repo, issue.number)
    request = Request(url)
    request.add_header('Authorization', 'token %s' % token)
    response = urlopen(request)
    response = json.loads(response.read().decode('utf-8'))
    to_write = to_write + "['issues'.{0}]\n".format(issue.number)
    to_write = to_write + 'title = "{0}" \n'.format(response.get('title'))
    to_write = to_write + 'number = "{0}" \n'.format(response.get('number'))
    to_write = to_write + 'body = """{0}""" \n'.format(response.get('body'))

    comment_url = response.get('comments_url')
    comment_count = 0
    most_recent = ""
    self_comment = False
    comment_dates = []
    comment_content = []
    comment_request = Request(comment_url)
    comment_response = urlopen(comment_request)
    comment_dict = json.loads(comment_response.read().decode('utf-8'))
    for c in list(comment_dict):
        comment_count = comment_count + 1
        comment_content.append(c.get("body"))
        date = c.get('updated_at')
        comment_dates.append(date)
        if most_recent == "" or date > most_recent:
            most_recent = date
        commenter = c.get('user').get('login')
        if commenter == username:
            self_comment = True
    to_write = to_write + 'comment_count = "{0}" \n'.format(comment_count)
    to_write = to_write + 'most_recent_comment = "{0}" \n'.format(most_recent)
    to_write = to_write + 'self_comment = "{0}" \n'.format(self_comment)
    to_write = to_write + 'comment_dates = "{0}" \n'.format(comment_dates)
    to_write = to_write + 'comment_body = {0} \n'.format(comment_content)
    return to_write


def sync():
    """Updates and saves pull-requests in pull-requests.toml in the .git folder. """
    username, repo, remotes = login()
    token = get_token()

    # saves pr into toml file
    try:
        g = github.Github(token)
        path_git = path_to_git()
        path_github = pjoin(path_git, 'git-hub')
        path_prs = path_to_toml()
        if not os.path.isdir(path_github):
            os.makedirs(path_github)
        f = open(path_prs, "w")
        to_write = "['open pull requests']\n"   # later will be convereted to toml to store
    except github.BadCredentialsException as e:
        print(e)
        click.echo("The authentification token is not valid.")
        sys.exit(1)

    # creates dictionaries in toml format as we scan though pull requests
    open_prs = g.get_user(username).get_repo(repo).get_pulls("open")
    for pr in open_prs:
        to_write = to_write + find_pr_info(username, repo, pr, token, "open")
    to_write = to_write[:-1]+'\n'
    to_write = to_write + "['closed pull requests'] \n"
    closed_prs = g.get_user(username).get_repo(repo).get_pulls("closed")
    for pr in closed_prs:
        to_write = to_write + find_pr_info(username, repo, pr, token, "closed")

    issues = g.get_user(username).get_repo(repo).get_issues()  # default is get open issues
    to_write = to_write + "['issues'] \n"
    for issue in issues:
        if f"pull requests'.{issue.number}" not in to_write:
            to_write = to_write + find_issue_info(username, repo, issue, token)
    # converts it to toml and stores in file
    toml_string = toml.loads(to_write)
    toml.dump(toml_string, f)


def render():
    app.main()


@click.group()
def cli():
    pass


@cli.command()
@click.argument("command", default="")
@click.argument("args", nargs=-1)
@click.option('--opened', '-o', default="", help="search by open or closed PRs")
@click.option('--user', '-u', default="", help="search by user")
@click.option('--branch', '-b', default="", help="search by branch")
@click.option('--comment', '-c', default="", help="search by comment")
@click.option('--number', '-n', default="", help="search by PR number")
@click.option('--sort', '-s', default="", help="sort PRs by increasing or decreasing date")
@click.option('--label', '-l', default="", help="search PR by label")
def hub(command, args, user, comment, number, branch, sort, opened, label):
    if command == "pr":
        pr_num = int(args[0])
        pr(pr_num)

    elif command == "push":
        push()

    elif command == "search":
        if(args is None):
            search(None, user, comment, number, branch, opened, label, sort)
        else:
            search(" ".join(args), user, comment, number, branch, opened, label, sort)
    elif command == "sync":
        sync()

    elif command == "info":
        pr_num = int(args[0])
        get_info(pr_num)

    elif command == "render":
        render()

    else:
        print("invalid command")
        sys.exit(1)


if __name__ == "__main__":
    hub()
